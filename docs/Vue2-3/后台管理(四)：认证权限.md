---
title: è®¤è¯ä¸æƒé™ç³»ç»Ÿå®ç°
---

# Vue3åå°ç®¡ç†ç³»ç»Ÿï¼ˆå››ï¼‰ï¼šè®¤è¯ä¸æƒé™ç³»ç»Ÿå®ç°

## ä¸€ã€è®¤è¯ç³»ç»Ÿè®¾è®¡

### 1.1 è®¤è¯æµç¨‹æ¦‚è¿°

åŸºäºJWT(JSON Web Token)å®ç°ï¼Œå®Œæ•´çš„è®¤è¯æµç¨‹å¦‚ä¸‹ï¼š

1. ç”¨æˆ·è¾“å…¥è´¦å·å¯†ç ï¼Œå‰ç«¯åŠ å¯†åå‘é€åˆ°æœåŠ¡å™¨
2. æœåŠ¡å™¨éªŒè¯æˆåŠŸåè¿”å›access_tokenå’Œrefresh_token
3. å‰ç«¯å­˜å‚¨tokenï¼Œå¹¶åœ¨åç»­è¯·æ±‚ä¸­æºå¸¦
4. è®¿é—®éœ€è¦æƒé™çš„èµ„æºæ—¶ï¼ŒæœåŠ¡ç«¯éªŒè¯tokenæœ‰æ•ˆæ€§å’Œæƒé™
5. tokenè¿‡æœŸæ—¶ï¼Œä½¿ç”¨refresh_tokenè·å–æ–°çš„access_token

### 1.2 Tokenç®¡ç†

é€šè¿‡å°è£…TokenServiceæ¥ç®¡ç†tokençš„å­˜å‚¨å’ŒéªŒè¯ï¼š

```javascript
// src/utils/token.js
/**
 * @description TokenæœåŠ¡ç±»
 * @Author Wangkaibing
 * @Date 2025-05-06
 *
 * Usage:
 * import { TokenService } from '@/utils/token'
 *
 * // è·å–token
 * TokenService.getToken()
 *
 * // è®¾ç½®token
 * TokenService.setTokens(accessToken, refreshToken, expiresIn)
 *
 * // æ¸…é™¤token
 * TokenService.clearTokens()
 */

import { setCookie, getCookie, removeCookie } from '@/utils/cookie'

export class TokenService {
	static TOKEN_KEY = 'xxxx'
	static REFRESH_TOKEN_KEY = 'xxxx'

	static getToken() {
		return getCookie(this.TOKEN_KEY)
	}

	static getRefreshToken() {
		return getCookie(this.REFRESH_TOKEN_KEY)
	}

	static setTokens(accessToken, refreshToken = '', expiresIn = 7200) {
		if (accessToken) {
			setCookie(this.TOKEN_KEY, accessToken, expiresIn)
		}
		if (refreshToken) {
			setCookie(this.REFRESH_TOKEN_KEY, refreshToken, expiresIn)
		}
	}

	static clearTokens() {
		removeCookie(this.TOKEN_KEY)
		removeCookie(this.REFRESH_TOKEN_KEY)
	}

	static isAuthenticated() {
		return !(!this.getToken() && !this.getRefreshToken())
	}
}
```

## äºŒã€ç™»å½•åŠŸèƒ½å®ç°

### 2.1 ç™»å½•ç»„åˆå¼API

ä½¿ç”¨ç»„åˆå¼API(Composition API)å°è£…ç™»å½•ç›¸å…³åŠŸèƒ½ï¼š

```javascript
/**
 * @description ç”¨æˆ·ç™»å½•ç®¡ç†hook
 * @Author Wangkaibing
 * @Date 2025-04-13
 *
 * Usageï¼š
 * import { useLogin } from '@/composables/useLogin'
 *
 * const { login, logout } = useLogin()
 * await login(loginForm)
 */

import { ref, reactive, computed, nextTick } from 'vue'
import { ElMessage } from 'element-plus'
import { useGet, usePost } from '@/api/request'
import { useAuthStore } from '@/stores/auth'
import { useUser } from '@/composables/useUser'
import { usePermissionStore } from '@/composables/usePermission'
import { useEncryption } from '@/composables/useEncryption.js'
import { useRouter } from 'vue-router'
import { TokenService } from '@/utils/token.js'
import { invalidateCache } from 'alova'

/**
 * ç™»å½•ç®¡ç†hook
 * ç™»å½•ã€é€€å‡ºã€è·å–éªŒè¯ç ç­‰åŠŸèƒ½
 * @returns {Object} ç™»å½•æ§åˆ¶å¯¹è±¡
 */
export function useLogin() {
	const router = useRouter()
	const authStore = useAuthStore()
	const { getUserInfo } = useUser()
	const permissionStore = usePermissionStore()
	const { encryptLoginData } = useEncryption()

	const loading = ref(false)
	const loginState = reactive({
		client: '',
		codeImage: '',
	})

	/**
	 * è·å–éªŒè¯ç 
	 * @param {boolean} isInit - æ˜¯å¦æ˜¯åˆå§‹åŒ–è°ƒç”¨
	 */
	const getCaptcha = async (isInit = false) => {
		try {
			const params = {
				width: 100,
				height: 42,
			}
			if (!isInit && loginState.client) {
				params.client = loginState.client
			}
			const res = await useGet('/api/xxxx', params, {
				loading: false,
			})
			if (res.image) {
				loginState.client = res.client
				loginState.codeImage = res.image
			}
		} catch (error) {
			console.log('ğŸš€ ~ [error]', error)
		}
	}

	/**
	 * ç”¨æˆ·ç™»å½•
	 * @param {Object} loginForm - ç™»å½•è¡¨å•æ•°æ®
	 */
	const login = async (loginForm) => {
		if (loading.value) return
		try {
			loading.value = true
			const loginData = encryptLoginData({
				username: loginForm.username,
				password: loginForm.password,
				verificationCode: loginForm.captcha,
				client: loginState.client,
			})
			const loginRes = await usePost('/api/xxxxx', loginData)
			if (!loginRes?.data) {
				throw new Error(loginRes?.message || 'ç™»å½•å¤±è´¥')
			}
			// æ¸…é™¤æ¥å£ç¼“å­˜
			invalidateCache()
			// ä¿å­˜token
			const { token_type, access_token, refresh_token, expires_in } = loginRes
			TokenService.setTokens(token_type + ' ' + access_token, refresh_token, expires_in * 1000)
			// è·å–ç”¨æˆ·ä¿¡æ¯
			await getUserInfo()
			// ç”Ÿæˆè·¯ç”±
			const accessRoutes = await permissionStore.generateRoutes(authStore.state.roles)
			// æ·»åŠ åŠ¨æ€è·¯ç”±
			accessRoutes.forEach((route) => {
				router.addRoute(route)
			})
			ElMessage({
				message: 'ç™»å½•æˆåŠŸï¼šæ¬¢è¿å›æ¥',
				type: 'success',
				plain: true,
			})
			await nextTick()
			await router.replace('/')
		} catch (error) {
			console.log('ğŸš€ ~ [error]', error)
			// å‘ç”Ÿé”™è¯¯æ—¶é‡ç½®çŠ¶æ€
			authStore.reset()
			permissionStore.resetRoutes()
			getCaptcha(false)
			throw error
		} finally {
			loading.value = false
		}
	}

	/**
	 * é€€å‡ºç™»å½•
	 */
	const logout = async () => {
		try {
			// æ¸…é™¤æ¥å£ç¼“å­˜
			invalidateCache()
			await router.push('/login')
			authStore.reset()
			permissionStore.resetRoutes()
		} catch (error) {
			console.log('ğŸš€ ~ [error]', error)
			authStore.reset()
			permissionStore.resetRoutes()
			// ä½¿ç”¨locationä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
			window.location.href = '/login'
		}
	}

	return {
		loading,
		codeImage: computed(() => loginState.codeImage),
		getCaptcha,
		login,
		logout,
	}
}
```

## ä¸‰ã€æƒé™ç³»ç»Ÿå®ç°

### 3.1 åŸºäºè§’è‰²çš„æƒé™æ§åˆ¶

ä½¿ç”¨ç»„åˆå¼APIå°è£…äº†æƒé™æ§åˆ¶é€»è¾‘ï¼š

```javascript
/**
 * @description è·¯ç”±æƒé™ç®¡ç†hook
 * @Author Wangkaibing
 * @Date 2025-04-13
 *
 * Usageï¼š
 * import { usePermissionStore } from '@/composables/usePermission'
 *
 * const permissionStore = usePermissionStore()
 * await permissionStore.generateRoutes(roles)
 */

import { ref, computed } from 'vue'
import { defineStore } from 'pinia'
import { constantRoutes, defaultRoutes, platform, catchAllRoute } from '@/router/routes'

export const usePermissionStore = defineStore('permission', () => {
	const routes = ref([...constantRoutes])
	const addRoutes = ref([])
	// æ·»åŠ è·¯ç”±å…ƒæ•°æ®ç¼“å­˜
	const routeMetaCache = ref(new Map())
	// æ·»åŠ è§’è‰²è·¯ç”±æ˜ å°„ç¼“å­˜
	const roleRoutesCache = ref(new Map())

	// è·¯ç”±æ˜¯å¦å·²ç»ç”Ÿæˆ
	const isRoutesGenerated = computed(() => addRoutes.value.length > 0)

	/**
	 * æ£€æŸ¥è·¯ç”±æƒé™
	 * @param {Array} roles - ç”¨æˆ·è§’è‰²åˆ—è¡¨
	 * @param {Object} route - è·¯ç”±å¯¹è±¡
	 * @returns {boolean} - æ˜¯å¦æœ‰æƒé™
	 */
	const hasPermission = (roles, route) => {
		// ç”Ÿæˆç¼“å­˜é”®
		const routePath = route.path
		const roleKey = roles.sort().join(',')
		const cacheKey = `${routePath}:${roleKey}`

		// æ£€æŸ¥ç¼“å­˜ä¸­æ˜¯å¦å­˜åœ¨
		if (routeMetaCache.value.has(cacheKey)) {
			return routeMetaCache.value.get(cacheKey)
		}

		// è®¡ç®—æƒé™å¹¶ç¼“å­˜ç»“æœ
		let hasAccess = true
		if (route.meta?.roles) {
			hasAccess = roles.some((role) => route.meta.roles.includes(role))
		}

		// ä¿å­˜åˆ°ç¼“å­˜
		routeMetaCache.value.set(cacheKey, hasAccess)
		return hasAccess
	}

	/**
	 * è¿‡æ»¤å¼‚æ­¥è·¯ç”±
	 * @param {Array} routes - è·¯ç”±é…ç½®æ•°ç»„
	 * @param {Array} roles - ç”¨æˆ·è§’è‰²åˆ—è¡¨
	 * @returns {Array} - è¿‡æ»¤åçš„è·¯ç”±
	 */
	const filterAsyncRoutes = (routes, roles) => {
		return routes
			.filter((route) => hasPermission(roles, route))
			.map((route) => {
				// åˆ›å»ºè·¯ç”±çš„æµ…æ‹·è´
				const tmp = { ...route }
				// é€’å½’å­è·¯ç”±
				if (tmp.children) {
					tmp.children = filterAsyncRoutes(tmp.children, roles)
				}
				return tmp
			})
	}

	/**
	 * ç”Ÿæˆå¯è®¿é—®è·¯ç”±
	 * @param {Array} roles - ç”¨æˆ·è§’è‰²åˆ—è¡¨
	 * @returns {Promise<Array>} - å¯è®¿é—®è·¯ç”±åˆ—è¡¨
	 */
	const generateRoutes = (roles) => {
		// ç”Ÿæˆè§’è‰²ç¼“å­˜é”®
		const roleKey = roles.sort().join(',')

		// å¦‚æœè§’è‰²è·¯ç”±ç¼“å­˜ä¸­å·²å­˜åœ¨ï¼Œç›´æ¥è¿”å›ç¼“å­˜ç»“æœ
		if (roleRoutesCache.value.has(roleKey)) {
			const cachedRoutes = roleRoutesCache.value.get(roleKey)
			addRoutes.value = cachedRoutes
			routes.value = [...constantRoutes, ...cachedRoutes]
			return Promise.resolve(cachedRoutes)
		}

		// è§’è‰²è·¯ç”±æ˜ å°„è¡¨ï¼Œé…ç½®æ¯ç§è§’è‰²å¯¹åº”çš„è·¯ç”±ç”Ÿæˆæ–¹æ³•
		const roleRouteMap = {
			'ROLE_ADMIN': () => [...defaultRoutes, ...platform, catchAllRoute],
			'ROLE_MANAGER': () => [...defaultRoutes, ...filterAsyncRoutes(platform, roles), catchAllRoute],
			'ROLE_SUPERVISOR': () => [...defaultRoutes, ...filterAsyncRoutes(platform, roles), catchAllRoute],
		}
		// é»˜è®¤è·¯ç”±
		const defaultRouteFn = () => [...defaultRoutes, catchAllRoute]
		// æŸ¥æ‰¾ç”¨æˆ·æ‹¥æœ‰çš„æœ€é«˜æƒé™è§’è‰²
		let routeGenerator = defaultRouteFn
		// éå†è§’è‰²ï¼Œæ‰¾åˆ°å¯¹åº”è·¯ç”±
		for (const role of roles) {
			if (roleRouteMap[role]) {
				routeGenerator = roleRouteMap[role]
				break // æ‰¾åˆ°ç¬¬ä¸€ä¸ªåŒ¹é…çš„è§’è‰²å°±åœæ­¢
			}
		}
		// ç”Ÿæˆè·¯ç”±
		const accessedRoutes = routeGenerator()

		// æ›´æ–°çŠ¶æ€
		addRoutes.value = accessedRoutes
		routes.value = [...constantRoutes, ...accessedRoutes]

		// ä¿å­˜åˆ°è§’è‰²è·¯ç”±ç¼“å­˜
		roleRoutesCache.value.set(roleKey, accessedRoutes)

		return Promise.resolve(accessedRoutes)
	}

	/**
	 * é‡ç½®è·¯ç”±é…ç½®
	 */
	const resetRoutes = () => {
		// æ¸…ç©ºåŠ¨æ€æ·»åŠ çš„è·¯ç”±
		addRoutes.value = []
		// é‡ç½®ä¸ºåˆå§‹è·¯ç”±
		routes.value = [...constantRoutes]
		// æ¸…ç©ºè·¯ç”±å…ƒæ•°æ®ç¼“å­˜
		routeMetaCache.value.clear()
		// æ¸…ç©ºè§’è‰²è·¯ç”±æ˜ å°„ç¼“å­˜
		roleRoutesCache.value.clear()
	}

	return {
		routes,
		addRoutes,
		isRoutesGenerated,
		generateRoutes,
		resetRoutes,
	}
})
```

### 3.2 è®¿é—®æ§åˆ¶æŒ‡ä»¤

ä¸ºäº†åœ¨é¡µé¢ä¸­æ§åˆ¶å…ƒç´ çš„æ˜¾ç¤ºï¼Œå®ç°è‡ªå®šä¹‰æŒ‡ä»¤ï¼š

```javascript
/**
 * @description æƒé™è®¿é—®æ§åˆ¶hook
 * @Author Wangkaibing
 * @Date 2025-04-13
 *
 * Usageï¼š
 * import { useAccess } from '@/composables/useAccess'
 *
 * const { hasRole, hasRoles } = useAccess()
 * hasRole('ROLE_ADMIN')
 */

import { computed } from 'vue'
import { defineStore } from 'pinia'
import { useAuthStore } from '@/stores/auth'

export const useAccessStore = defineStore('access', () => {
	const authStore = useAuthStore()

	// è®¡ç®—å±æ€§ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºç®¡ç†å‘˜
	const isAdmin = computed(() => {
		return authStore.state.roles.includes('ROLE_ADMIN')
	})

	return {
		isAdmin,
	}
})

/**
 * æƒé™è®¿é—®æ§åˆ¶hook
 * æä¾›åŸºäºè§’è‰²çš„æƒé™éªŒè¯åŠŸèƒ½
 */
export function useAccess() {
	const accessStore = useAccessStore()
	const authStore = useAuthStore()

	/**
	 * åˆ¤æ–­æ˜¯å¦æ‹¥æœ‰æŒ‡å®šè§’è‰²
	 * @param {string} role - è§’è‰²æ ‡è¯†
	 * @returns {boolean} - æ˜¯å¦æ‹¥æœ‰è¯¥è§’è‰²
	 */
	const hasRole = (role) => {
		if (!role || !authStore.state.roles.length) {
			return false
		}
		return authStore.state.roles.includes(role)
	}

	/**
	 * åˆ¤æ–­æ˜¯å¦æ‹¥æœ‰æŒ‡å®šè§’è‰²é›†åˆä¸­çš„ä»»æ„ä¸€ä¸ª
	 * @param {string[]} roles - è§’è‰²æ ‡è¯†æ•°ç»„
	 * @param {boolean} every - æ˜¯å¦éœ€è¦æ»¡è¶³æ‰€æœ‰è§’è‰²ï¼Œé»˜è®¤false
	 * @returns {boolean} - æ˜¯å¦æ»¡è¶³è§’è‰²è¦æ±‚
	 */
	const hasRoles = (roles, every = false) => {
		if (!roles || !roles.length || !authStore.state.roles.length) {
			return false
		}
		const verify = (role) => hasRole(role)
		return every ? roles.every(verify) : roles.some(verify)
	}

	// è§’è‰²æŒ‡ä»¤
	const vRole = {
		mounted(el, binding) {
			const { value } = binding
			const hasPermission = Array.isArray(value) ? hasRoles(value) : hasRole(value)

			if (!hasPermission) {
				el.parentNode?.removeChild(el)
			}
		},
	}

	return {
		...accessStore,
		hasRole,
		hasRoles,
		vRole,
	}
}
```

è‡ªå®šä¹‰æŒ‡ä»¤çš„æ³¨å†Œï¼š

```javascript
/**
 * @description è§’è‰²æƒé™æŒ‡ä»¤
 * @Author Wangkaibing
 * @Date 2025-04-13
 * @Usage
 * // å•ä¸ªè§’è‰²
 * <button v-role="'ROLE_ADMIN'">ç®¡ç†å‘˜æ“ä½œ</button>
 *
 * // å¤šä¸ªè§’è‰²ï¼ˆæ»¡è¶³å…¶ä¸€ï¼‰
 * <button v-role="['ROLE_ADMIN', 'ROLE_MANAGER']">ç®¡ç†æ“ä½œ</button>
 */

import { useAccess } from '@/composables/useAccess'

/**
 * æ³¨å†Œå…¨å±€è§’è‰²æƒé™æŒ‡ä»¤
 * @param {Object} app - Vueåº”ç”¨å®ä¾‹
 */
export function setupPermissionDirective(app) {
	const { vRole } = useAccess()

	// æ³¨å†Œ v-role æŒ‡ä»¤
	app.directive('role', vRole)
}
```

### 3.3 è·¯ç”±å®ˆå«ä¸­çš„æƒé™æ§åˆ¶

åœ¨è·¯ç”±å®ˆå«ä¸­ï¼Œå®ç°åŸºäºtokenå’Œè§’è‰²çš„è®¿é—®æ§åˆ¶ï¼š

```javascript
// src/router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import { constantRoutes } from './routes'
import { ElNotification } from 'element-plus'
import { useAuthStore } from '@/stores/auth'
import { useUser } from '@/composables/useUser'
import { usePermissionStore } from '@/composables/usePermission'
import NProgress from 'nprogress'
import '@/styles/nprogress.scss'
import { TokenService } from '@/utils/token.js'

// é…ç½® NProgress
NProgress.configure({
	easing: 'ease-out',
	speed: 400,
	showSpinner: false,
	trickleSpeed: 200,
	minimum: 0.3,
})

// ä¿®å¤é‡å¤ç‚¹å‡»è·¯ç”±æŠ¥é”™é—®é¢˜
const originalPush = createRouter.prototype.push
createRouter.prototype.push = function push(location) {
	return originalPush.call(this, location).catch((err) => err)
}

const router = createRouter({
	history: createWebHistory(),
	scrollBehavior: () => ({ top: 0 }),
	routes: [...constantRoutes],
})

// å¼‚æ­¥ç»„ä»¶åŠ è½½å¤±è´¥
router.onError((error) => {
	const pattern = /Loading chunk (\d)+ failed/g
	const isChunkLoadFailed = error.message.match(pattern)
	if (isChunkLoadFailed) {
		window.location.reload()
	}
})

// è·¯ç”±ç™½åå•
const whiteList = ['/login']

// è·¯ç”±å®ˆå«
router.beforeEach(async (to, from, next) => {
	// å¼€å¯è¿›åº¦æ¡
	NProgress.start()

	const authStore = useAuthStore()
	const { getUserInfo } = useUser()
	const permissionStore = usePermissionStore()

	// ç™½åå•ç›´æ¥é€šè¿‡
	if (whiteList.includes(to.path)) {
		return next()
	}

	// URLä¸­çš„token
	if (to.query.token) {
		const token = to.query.token
		TokenService.setTokens('Bearer ' + token)
		// ç§»é™¤tokenå‚æ•°ï¼Œé¿å…æš´éœ²åœ¨URLä¸­
		const { token: _, ...query } = to.query
		return next({ path: to.path, query })
	}

	// æ£€æŸ¥æ˜¯å¦å·²ç™»å½•
	if (!authStore.isAuthenticated) {
		ElNotification({
			title: 'ç™»å½•å¤±è´¥',
			message: 'ç™»å½•è¿‡æœŸ',
			type: 'error',
		})
		return next(`/login?redirect=${to.path}`)
	}

	try {
		// åªåœ¨é¦–æ¬¡åŠ è½½æˆ–åˆ·æ–°é¡µé¢æ—¶æ‰§è¡Œè·¯ç”±ç”Ÿæˆ
		if (!permissionStore.isRoutesGenerated) {
			// å¦‚æœæ²¡æœ‰è§’è‰²ä¿¡æ¯ï¼Œå…ˆè·å–ç”¨æˆ·ä¿¡æ¯
			if (!authStore.hasRoles) {
				await getUserInfo()
			}
			// ç”ŸæˆåŠ¨æ€è·¯ç”±
			const accessRoutes = await permissionStore.generateRoutes(authStore.state.roles)
			// æ·»åŠ åŠ¨æ€è·¯ç”±
			accessRoutes.forEach((route) => {
				router.addRoute(route)
			})
			// é‡å®šå‘åˆ°åŸç›®æ ‡ï¼Œç¡®ä¿è·¯ç”±å·²æ›´æ–°
			return next({ ...to, replace: true })
		}

		// é»˜è®¤é¦–é¡µé‡å®šå‘åˆ°è´¦æˆ·é¡µ
		if (to.path === '/') {
			return next({ path: '/my/account', replace: true })
		}

		next()
	} catch (error) {
		// å¼‚å¸¸
		console.log('ğŸš€ ~ [error]', error)
		authStore.reset()
		permissionStore.resetRoutes()
		ElNotification({
			title: 'é”™è¯¯',
			message: error.message || 'ç™»å½•å¤±è´¥ï¼Œè¯·é‡æ–°ç™»å½•',
			type: 'error',
		})
		next('/login')
	}
})

// è·¯ç”±åç½®å®ˆå«
router.afterEach(() => {
	// ç»“æŸè¿›åº¦æ¡
	NProgress.done()
})
```

## å››ã€å‰ç«¯æƒé™åº”ç”¨åœºæ™¯

### 4.1 åŸºäºè§’è‰²çš„æŒ‰é’®æƒé™

åœ¨å®é™…ä¸šåŠ¡ä¸­å¯ä»¥è¿™æ ·ä½¿ç”¨è‡ªå®šä¹‰æŒ‡ä»¤ï¼š

```vue
<template>
  <!-- æ ¹æ®è§’è‰²æ§åˆ¶æŒ‰é’®æ˜¾ç¤º -->
  <el-button v-role="'ROLE_ADMIN'" type="primary">ç®¡ç†å‘˜ä¸“ç”¨æŒ‰é’®</el-button>
  
  <!-- æ”¯æŒå¤šä¸ªè§’è‰²ï¼ˆæ»¡è¶³ä¸€ä¸ªå³å¯æ˜¾ç¤ºï¼‰ -->
  <el-button v-role="['ROLE_ADMIN', 'ROLE_MANAGER']">ç®¡ç†æ“ä½œæŒ‰é’®</el-button>
</template>
```

